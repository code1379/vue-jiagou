<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div id="app"></div>
  <!-- <script type="module">
    // vue 在 runtime-dom 中提供了一个方法，这个方法运行用户自定义的渲染方式
    // mpvue 基于 vue 源码进行改造
    // 针对 canvas 来进行渲染，自己定义渲染方式
    import { createRenderer, h } from '/node_modules/@vue/runtime-dom/dist/runtime-dom.esm-browser.js'

    // 虚拟DOM，好处就是跨平台 {div, 属性，内容是什么} 可以做diff 肃反
    // 我们的核心就是利用渲染器来渲染我们的虚拟DOM

    const VDom = h("div", 'hello')
    console.log('VDom', VDom)
    const renderer = createRenderer({
      insert(element, container) {
        container.appendChild(element)
      },
      createElement(element) {
        return document.createElement(element)
      },
      setElementText(element, text) {
        element.innerHTML = text
      },
    })
    renderer.render(VDom, app)
  </script> -->

  <!-- <script type="module">
    // vue 在 runtime-dom 中提供了一个方法，这个方法运行用户自定义的渲染方式
    // mpvue 基于 vue 源码进行改造
    // 针对 canvas 来进行渲染，自己定义渲染方式
    // import { createRenderer, h, render } from '/node_modules/@vue/runtime-dom/dist/runtime-dom.esm-browser.js'

    // 虚拟DOM，好处就是跨平台 {div, 属性，内容是什么} 可以做diff 肃反
    // 我们的核心就是利用渲染器来渲染我们的虚拟DOM

    const VDom = h("div", 'hello')
    render(VDom, app)
  </script> -->

  <script type="module">
    import "./runtime-dom.js"
  </script>
</body>

</html>